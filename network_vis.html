<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Online Social Network</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <style>
    :root {
      --positive: #4caf50;
      --negative: #e74c3c;
      --neutral: #f3f3f3;
      --stroke: #888;
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --font-header: 20px;
      --font-body: 14px;
      --font-legend: 12px;
      --font-label: 10px;
      --font-timeline: 14px;
      --font-sidebar: 13px;
      --font-tooltip: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, #1f2937 0%, #0b1222 55%, #050a14 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      font-size: var(--font-body);
    }
    header { padding: 18px 20px 10px; color: #cbd5e1; }
    h1 { margin: 0; font-weight: 600; letter-spacing: 0.3px; font-size: var(--font-header); }
    #main { display: flex; flex: 1; min-height: 0; }
    #chart { flex: 1; position: relative; }
    svg { width: 100%; height: calc(100vh - 170px); display: block; }
    #sidebar { width: 190px; background: rgba(17, 24, 39, 0.8); border-left: 1px solid #1f2937; display: flex; flex-direction: column; padding: 14px 12px; gap: 10px; }
    .mode-title { font-size: var(--font-legend); text-transform: uppercase; letter-spacing: 0.6px; color: #9ca3af; margin-bottom: 4px; }
    .mode-btn { padding: 10px 12px; background: #111827; border: 1px solid #1f2937; border-radius: 10px; color: #e5e7eb; font-size: var(--font-sidebar); cursor: pointer; text-align: left; transition: all 0.15s ease; }
    .mode-btn:hover { border-color: #2563eb; color: #bfdbfe; }
    .mode-btn.active { background: linear-gradient(135deg, rgba(37, 99, 235, 0.28), rgba(59, 130, 246, 0.16)); border-color: #2563eb; color: #fff; box-shadow: 0 4px 12px rgba(37, 99, 235, 0.35); }
    .link { stroke: #64748b; stroke-opacity: 0.5; }
    .node { stroke: var(--stroke); stroke-width: 1.2px; cursor: grab; }
    .label { fill: #cbd5e1; font-size: var(--font-label); pointer-events: none; }
    footer { padding: 12px 20px 2px; background: linear-gradient(180deg, rgba(10,15,30,0) 0%, #0a0f1e 35%, #0a0f1e 100%); border-top: 1px solid #1f2937; }
    .timeline { display: flex; align-items: center; gap: 12px; color: #cbd5e1; font-size: var(--font-timeline); }
    input[type="range"] { flex: 1; appearance: none; height: 6px; background: #1f2937; border-radius: 999px; outline: none; }
    input[type="range"]::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(135deg, #22c55e 0%, #22d3ee 100%); border: 2px solid #0f172a; box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.28); cursor: pointer; }
    .legend { display: flex; gap: 12px; font-size: var(--font-legend); margin-top: 6px; color: #94a3b8; align-items: center; flex-wrap: wrap; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid var(--stroke); }
    .dataset-picker { display: flex; flex-direction: column; gap: 6px; font-size: var(--font-body); color: #cbd5e1; margin-bottom: 10px; }
    .dataset-picker label { font-size: var(--font-legend); color: #94a3b8; }
    .dataset-picker select { background: #0f172a; color: #e5e7eb; border: 1px solid #1f2937; border-radius: 8px; padding: 6px 8px; font-size: var(--font-body); outline: none; }
    .dataset-picker select:focus { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.35); }
    .bubble { pointer-events: auto; }
    .bubble rect { fill: rgba(255, 255, 255, 0.08); stroke: #38bdf8; stroke-width: 1.4px; rx: 6; ry: 6; }
    .bubble text { fill: #e0f2fe; font-size: 10px; pointer-events: none; }
  </style>
</head>
<body>
  <header>
    <h1>Online Social Network</h1>
    <div class="legend"></div>
  </header>

  <div id="main">
    <div id="chart"><svg></svg></div>
    <aside id="sidebar">
      <div class="dataset-picker">
        <label for="datasetSelect">Dataset</label>
        <select id="datasetSelect">
          <option value="BLM" selected>BLM</option>
          <option value="Stock">Stock</option>
        </select>
      </div>
      <div class="mode-title">Modes</div>
      <button class="mode-btn active" data-mode="attitude">Attitude</button>
      <button class="mode-btn" data-mode="news">News Diffusion</button>
      <button class="mode-btn" data-mode="emotion">Emotion</button>
    </aside>
  </div>

  <footer>
    <div class="timeline">
      <span>Round</span>
      <input id="roundSlider" type="range" min="1" max="9" value="1" step="1">
      <span id="roundLabel">1</span>
    </div>
  </footer>

  <script>
    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = Math.max(520, window.innerHeight - 200);
    const getLinkDistance = () => {
      const base = Math.min(width, height) * 0.95; // scale with viewport
      const sizeFactor = nodes.length ? Math.max(0.35, 1 - Math.log(nodes.length) / 10) : 1;
      return Math.max(180, base * sizeFactor); // keep a floor to avoid overlap
    };
    svg.attr("viewBox", [0, 0, width, height]);

    const datasets = { BLM: "BLM_translated.csv", Stock: "Stock_translated.csv" };
    const edgeFiles = { BLM: "network_edge_BLM.csv", Stock: "network_edge_Stock.csv" };

    const normalizeBool = (v) => v === true || v === "TRUE" || v === "True" || v === "true" || v === "1";
    const colorForAttitude = (attitude) => {
      if (!attitude) return "var(--neutral)";
      const v = attitude.toString().toLowerCase();
      if (v === "neutral") return "#fbbf24";
      if (v === "like" || v === "positive") return "var(--positive)";
      if (v === "dislike" || v === "negative") return "var(--negative)";
      return "var(--neutral)";
    };
    const colorForNews = (knows, shock) => {
      const n = normalizeBool(knows);
      const s = normalizeBool(shock);
      if (n && s) return "#ef4444";
      if (n) return "#3b82f6";
      return "#f8fafc";
    };
    const emotionColors = new Map();
    const emotionValues = new Set();
    const palette = ["#f59e0b", "#8b5cf6", "#10b981", "#ec4899", "#06b6d4", "#f97316", "#22c55e", "#eab308", "#3b82f6", "#ef4444", "#14b8a6", "#a855f7"];
    const colorForEmotion = (emotion) => {
      if (!emotion) return "var(--neutral)";
      const key = emotion.trim();
      return emotionColors.get(key) || "var(--neutral)";
    };

    const attitudeByRound = new Map();
    const newsByRound = new Map();
    const shockByRound = new Map();
    const infoByRound = new Map();
    const postsByRound = new Map();
    let legendLabels = {
      attitude: ["Positive (LIKE)", "Negative (DISLIKE)", "None / Missing"],
      news: ["Knows News (True)", "Unknown (False/NA)"],
      attitude_neutral: "Neutral (NEUTRAL)",
      news_shock: "Knows Shock (True+True)"
    };
    let fontSizes = { header: "20px", body: "14px", legend: "12px", label: "10px", timeline: "14px", sidebar: "13px", tooltip: "12px" };
    let maxRound = 9;
    let hasNeutralAttitude = false;
    let hasShockTrue = false;

    let edgesByDatasetRaw = {};
    let nodes = [];
    let edges = [];
    let mode = "attitude";
    let currentRound = 1;

    const linkG = svg.append("g");
    const nodeG = svg.append("g");
    const labelG = svg.append("g");
    const bubbleLayer = svg.append("g").attr("class", "bubbles");
    let linkSel = linkG.selectAll("line");
    let nodeSel = nodeG.selectAll("circle");
    let labelSel = labelG.selectAll("text");
    let nodeById = new Map();
    let simulation;

    const tooltip = d3.select("body").append("div")
      .style("position", "fixed").style("pointer-events", "none").style("background", "rgba(10, 14, 25, 0.9)")
      .style("color", "#e5e7eb").style("padding", "10px 12px").style("border", "1px solid #1f2937")
      .style("border-radius", "8px").style("font-size", "var(--font-tooltip)")
      .style("box-shadow", "0 10px 30px rgba(0,0,0,0.35)")
      .style("opacity", 0);

    const slider = document.getElementById("roundSlider");
    const roundLabel = document.getElementById("roundLabel");
    const datasetSelect = document.getElementById("datasetSelect");
    const legendEl = d3.select(".legend");

    const applyFontSizes = (sizes) => {
      const root = document.documentElement;
      root.style.setProperty("--font-header", sizes.header || fontSizes.header);
      root.style.setProperty("--font-body", sizes.body || fontSizes.body);
      root.style.setProperty("--font-legend", sizes.legend || fontSizes.legend);
      root.style.setProperty("--font-label", sizes.label || fontSizes.label);
      root.style.setProperty("--font-timeline", sizes.timeline || fontSizes.timeline);
      root.style.setProperty("--font-sidebar", sizes.sidebar || fontSizes.sidebar);
      root.style.setProperty("--font-tooltip", sizes.tooltip || fontSizes.tooltip);
    };

    const renderLegend = (mode) => {
      legendEl.selectAll("*").remove();
      if (mode === "attitude") {
        legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: var(--positive); border: none;"></span>${legendLabels.attitude[0]}`);
        legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: var(--negative); border: none;"></span>${legendLabels.attitude[1]}`);
        if (hasNeutralAttitude) legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: #fbbf24; border: none;"></span>${legendLabels.attitude_neutral || "Neutral (NEUTRAL)"}`);
        legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: var(--neutral);"></span>${legendLabels.attitude[2]}`);
      } else if (mode === "news") {
        legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: #3b82f6; border: none;"></span>${legendLabels.news[0]}`);
        legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: #f8fafc; border: 1px solid var(--stroke);"></span>${legendLabels.news[1]}`);
        if (hasShockTrue) legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: #ef4444; border: none;"></span>${legendLabels.news_shock || "Knows Shock (True+True)"}`);
      } else if (mode === "emotion") {
        if (emotionColors.size === 0) legendEl.append("span").attr("class", "legend-item").text("No emotion data");
        else emotionColors.forEach((color, em) => {
          legendEl.append("span").attr("class", "legend-item").html(`<span class="legend-swatch" style="background: ${color}; border: none;"></span>${em}`);
        });
      }
    };

    const resetMaps = () => {
      attitudeByRound.clear(); newsByRound.clear(); shockByRound.clear();
      infoByRound.clear(); postsByRound.clear();
      emotionColors.clear(); emotionValues.clear();
      hasNeutralAttitude = false; hasShockTrue = false;
    };

    const parseRows = (rows) => {
      resetMaps(); maxRound = 1;
      rows.forEach(d => {
        const round = +d.round_num; const id = +d.user_id; if (round > maxRound) maxRound = round;
        const att = d.attitude_update;
        if (att && att.toString().toLowerCase() === "neutral") hasNeutralAttitude = true;

        const emotionFields = [d.emotion_4, d.emotion_3, d.emotion_2, d.emotion_1];
        const intensityFields = [d.emotion_intensity_4, d.emotion_intensity_3, d.emotion_intensity_2, d.emotion_intensity_1];
        const explanationFields = [d.emotion_explanation_4, d.emotion_explanation_3, d.emotion_explanation_2, d.emotion_explanation_1];
        const emotion = emotionFields.find(v => v && v.trim() !== "") || "";
        const emotionIntensity = intensityFields.find(v => v && v.trim() !== "") || "";
        const emotionExplanation = explanationFields.find(v => v && v.trim() !== "") || "";
        const preference = (d.preference_update && d.preference_update.trim() !== "" ? d.preference_update : d.preference_initial) || "";

        const knows = d.know_news;
        const shock = d.know_shock;
        if (normalizeBool(knows) && normalizeBool(shock)) hasShockTrue = true;

        if (!attitudeByRound.has(round)) attitudeByRound.set(round, new Map());
        attitudeByRound.get(round).set(id, att);
        if (!newsByRound.has(round)) newsByRound.set(round, new Map());
        newsByRound.get(round).set(id, knows);
        if (!shockByRound.has(round)) shockByRound.set(round, new Map());
        shockByRound.get(round).set(id, shock);
        if (!infoByRound.has(round)) infoByRound.set(round, new Map());
        infoByRound.get(round).set(id, { preference: preference || "", emotion: emotion || "", emotionIntensity: emotionIntensity || "", emotionExplanation: emotionExplanation || "", selfEfficacy: d.self_efficacy || "", outcome: d.outcome_expectation || "" });
        if (emotion && emotion.trim() !== "") emotionValues.add(emotion.trim());
        if (!postsByRound.has(round)) postsByRound.set(round, new Map());
        if (d.post_content && d.post_content.trim() !== "") postsByRound.get(round).set(id, d.post_content);
      });
      Array.from(emotionValues).sort().forEach((em, idx) => emotionColors.set(em, palette[idx % palette.length]));
      slider.max = maxRound; if (currentRound > maxRound) currentRound = maxRound; slider.value = currentRound; roundLabel.textContent = currentRound;
    };

    const applyRound = (round) => {
      const attMap = attitudeByRound.get(round) || new Map();
      const newsMap = newsByRound.get(round) || new Map();
      const shockMap = shockByRound.get(round) || new Map();
      const infoMap = infoByRound.get(round) || new Map();
      const postMap = postsByRound.get(round) || new Map();

      nodeSel.attr("fill", d => {
        if (mode === "attitude") return colorForAttitude(attMap.get(d.id));
        if (mode === "news") return colorForNews(newsMap.get(d.id), shockMap.get(d.id));
        const info = infoMap.get(d.id) || {}; return colorForEmotion(info.emotion);
      }).attr("stroke", d => {
        let fill;
        if (mode === "attitude") fill = colorForAttitude(attMap.get(d.id));
        else if (mode === "news") fill = colorForNews(newsMap.get(d.id), shockMap.get(d.id));
        else fill = colorForEmotion((infoMap.get(d.id) || {}).emotion);
        return fill === "var(--neutral)" ? "var(--stroke)" : "#0f172a";
      });

      const bubbleData = nodes.filter(n => postMap.get(n.id));
      const bubbles = bubbleLayer.selectAll(".bubble").data(bubbleData, d => d.id);
      const bubblesEnter = bubbles.enter().append("g").attr("class", "bubble");
      bubblesEnter.append("rect").attr("x", -18).attr("y", -14).attr("width", 36).attr("height", 18);
      bubblesEnter.append("text").attr("text-anchor", "middle").attr("dy", -2).text("post");

      const bubblesMerged = bubbles.merge(bubblesEnter).attr("transform", d => {
        const n = nodeById.get(d.id);
        return n ? `translate(${n.x}, ${n.y - 20})` : "translate(0,0)";
      });

      bubblesMerged.on("mousemove", (event, d) => {
        const postMapNow = postsByRound.get(round) || new Map();
        const content = postMapNow.get(d.id) || "N/A";
        tooltip.html(`<div><strong>Post:</strong> ${content}</div>`)
          .style("left", (event.clientX + 12) + "px")
          .style("top", (event.clientY + 12) + "px")
          .style("opacity", 1);
      }).on("mouseleave", () => tooltip.style("opacity", 0));

      bubbles.exit().remove();
    };

    const rebuildGraph = (edgesNew) => {
      // coerce edges back to plain number pairs to avoid mutated objects from forceLink
      edges = edgesNew.map(e => ({ source: +e.source, target: +e.target }));
      const nodeIds = new Set();
      edges.forEach(e => { nodeIds.add(e.source); nodeIds.add(e.target); });
      nodes = Array.from(nodeIds).sort((a, b) => a - b).map(id => ({ id }));
      nodeById = new Map(nodes.map(n => [n.id, n]));

      linkSel = linkSel.data(edges, d => `${d.source}-${d.target}`);
      linkSel.exit().remove();
      const linkEnter = linkSel.enter().append("line").attr("class", "link").attr("marker-end", "url(#arrow)");
      linkSel = linkEnter.merge(linkSel);

      nodeSel = nodeSel.data(nodes, d => d.id);
      nodeSel.exit().remove();
      const nodeEnter = nodeSel.enter().append("circle").attr("class", "node").attr("r", 9).call(drag(simulation));
      nodeSel = nodeEnter.merge(nodeSel);

      labelSel = labelSel.data(nodes, d => d.id);
      labelSel.exit().remove();
      const labelEnter = labelSel.enter().append("text").attr("class", "label").attr("dy", 3).text(d => d.id);
      labelSel = labelEnter.merge(labelSel).text(d => d.id);

      simulation.nodes(nodes);
      simulation.force("link").distance(getLinkDistance).links(edges);
      simulation.alpha(0.6).restart();
    };

    Promise.all([
      d3.csv(edgeFiles.BLM, d => ({ source: +d.start, target: +d.end })),
      d3.csv(edgeFiles.Stock, d => ({ source: +d.start, target: +d.end })),
      d3.json("legend_labels.json").catch(() => null),
      d3.json("font_sizes.json").catch(() => null)
    ]).then(([edgesBLM, edgesStock, legendCfg, fontCfg]) => {
      // keep an immutable copy so force mutations do not pollute future reloads
      edgesByDatasetRaw = {
        BLM: edgesBLM.map(e => ({ source: e.source, target: e.target })),
        Stock: edgesStock.map(e => ({ source: e.source, target: e.target }))
      };
      if (legendCfg) legendLabels = { ...legendLabels, ...legendCfg };
      if (fontCfg) fontSizes = { ...fontSizes, ...fontCfg };
      applyFontSizes(fontSizes);

      simulation = d3.forceSimulation()
        .alpha(0.35).alphaDecay(0.08).velocityDecay(0.55)
        .force("link", d3.forceLink().id(d => d.id).distance(getLinkDistance).strength(0.7))
        .force("charge", d3.forceManyBody().strength(-140))
        .force("center", d3.forceCenter(width / 2, height / 2 - 40))
        .force("collide", d3.forceCollide(16));

      simulation.on("tick", () => {
        linkSel.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        nodeSel.attr("cx", d => d.x).attr("cy", d => d.y);
        labelSel.attr("x", d => d.x + 11).attr("y", d => d.y + 3);
        bubbleLayer.selectAll(".bubble").attr("transform", d => {
          const n = nodeById.get(d.id);
          return n ? `translate(${n.x}, ${n.y - 20})` : "translate(0,0)";
        });
      });

      const bindNodeHover = () => {
        nodeSel.on("mousemove", (event, d) => {
          const infoMap = infoByRound.get(currentRound) || new Map();
          const info = infoMap.get(d.id) || {};
          tooltip.html(`
            <div><strong>Attitude:</strong> ${info.preference || "N/A"}</div>
            <div><strong>Emotion:</strong> ${info.emotion || "N/A"}${info.emotionIntensity ? ", intensity " + info.emotionIntensity : ""}${info.emotionExplanation ? ", " + info.emotionExplanation : ""}</div>
            <div><strong>Self-efficacy:</strong> ${info.selfEfficacy || "N/A"}</div>
            <div><strong>Outcome Expectancy:</strong> ${info.outcome || "N/A"}</div>
          `)
          .style("left", (event.clientX + 12) + "px")
          .style("top", (event.clientY + 12) + "px")
          .style("opacity", 1);
        }).on("mouseleave", () => tooltip.style("opacity", 0));
      };

      const loadDataset = (key) => {
        const file = datasets[key] || datasets.BLM;
        const raw = edgesByDatasetRaw[key] || edgesByDatasetRaw.BLM || [];
        const edgeSet = raw.map(e => ({ source: e.source, target: e.target })); // fresh copy so d3 can mutate safely
        d3.csv(file).then(rows => {
          currentRound = 1;
          parseRows(rows);
          rebuildGraph(edgeSet);
          renderLegend(mode);
          applyRound(currentRound);
          bindNodeHover();
        }).catch(() => alert(`Failed to load dataset: ${file}`));
      };

      const buttons = document.querySelectorAll(".mode-btn");
      buttons.forEach(btn => btn.addEventListener("click", () => {
        buttons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        mode = btn.dataset.mode;
        renderLegend(mode);
        applyRound(currentRound);
      }));

      slider.addEventListener("input", e => { currentRound = +e.target.value; roundLabel.textContent = currentRound; applyRound(currentRound); });
      datasetSelect.addEventListener("change", e => { loadDataset(e.target.value); });

      renderLegend(mode);
      loadDataset("BLM");
    });

    function drag(simulation) {
      function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.2).restart(); d.fx = d.x; d.fy = d.y; }
      function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
      function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
      return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }
  </script>
</body>
</html>
